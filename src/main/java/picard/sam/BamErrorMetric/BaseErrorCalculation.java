/*
 * The MIT License
 *
 * Copyright (c) 2018 The Broad Institute
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package picard.sam.BamErrorMetric;

import htsjdk.samtools.SAMRecord;
import htsjdk.samtools.util.SamLocusIterator;
import htsjdk.samtools.util.SequenceUtil;
import org.broadinstitute.barclay.argparser.CommandLineParser;

import java.util.function.Supplier;

/**
 * An interface and implementations for classes the look at a collection of bases in reads and computes various ErrorMetrics from them.
 *
 * @author Yossi Farjoun
 */

public class BaseErrorCalculation {

    /**
     * An interface that can take a collection of bases (provided as {@link htsjdk.samtools.util.SamLocusIterator.RecordAndOffset RecordAndOffset}
     * and {@link SAMLocusAndReferenceIterator.SAMLocusAndReference SAMLocusAndReference}) and generates a
     * {@link ErrorMetrics.ComputableMetricBase} from them.
     * <p>
     * The Calculator has a suffix which will be used to generate the metric file suffixes.
     */
    public interface BaseCalculator {

        // The suffix that pertains to the implementation of aggregation
        String getSuffix();

        // returns the metric generated by the observed loci
        ErrorMetrics.ComputableMetricBase getMetric();

        // the function by which new loci are "shown" to the calculator
        void addBase(final SamLocusIterator.RecordAndOffset recordAndOffset,
                     final SAMLocusAndReferenceIterator.SAMLocusAndReference locusInfo);
    }

    /**
     * An enum that is used to generate a {@link Supplier<BaseErrorCalculator>} from a string
     * To use this given a String 'str':
     * <p>
     * Errors.valueOf(str).getErrorSupplier()
     * <p>
     * This is used in {@link CollectBamErrorMetrics} to convert an input argument to a {@link BaseErrorAggregation}.
     */
    enum Errors implements CommandLineParser.ClpEnum {
        ERROR(BaseErrorCalculator::new, "Collects the average error at the bases provided."),
        OVERLAPPING_ERROR(OverlappingReadsErrorCalculator::new, "Only considers bases from the overlapping parts of reads from the same template. " +
                "For those bases, it calculates the error that can be attributable to pre-sequencing, versus during-sequencing.");

        final private Supplier<? extends BaseCalculator> errorSupplier;

        Errors(Supplier<? extends BaseCalculator> errorSupplier, final String docString) {
            this.errorSupplier = errorSupplier;
            this.docString = docString;
        }

        public Supplier<? extends BaseCalculator> getErrorSupplier() {
            return errorSupplier;
        }

        private final String docString;

        @Override
        public String getHelpDoc() {
            return docString + " Suffix is: " + errorSupplier.get().getSuffix();
        }
    }

    /**
     * A calculator that estimates the error rate of the bases it observes, assuming that the reference is truth.
     */
    public static class BaseErrorCalculator implements BaseCalculator {

        long nMismatchingBases = 0;
        long totalBases = 0;

        @Override
        public void addBase(final SamLocusIterator.RecordAndOffset recordAndOffset, final SAMLocusAndReferenceIterator.SAMLocusAndReference locusInfo) {
            final byte readBase = recordAndOffset.getReadBase();
            if (!SequenceUtil.isNoCall(readBase)) {
                totalBases++;
                if (readBase != locusInfo.referenceBase) {
                    nMismatchingBases++;
                }
            }
        }

        @Override
        public String getSuffix() {
            return "error";
        }

        @Override
        public ErrorMetrics.ComputableMetricBase getMetric() {
            return new ErrorMetrics.SimpleErrorMetric("", totalBases, nMismatchingBases);
        }
    }

    /**
     * A calculator that estimates the error rate of the bases it observes, assuming that the reference is truth.
     * This calculator only includes bases that have been read twice in the same template (once from each read) and
     * thus only includes bases that arise from the overlapping part of the reads. Over those bases the Calculator
     * distinguishes between weather the two reads agree with each other but differ from the reference (indicative
     * of a difference between the template and the reference, and when one of the reads agrees with the reference
     * but the other does not which indicates that there might have been a sequencing error in that read.
     */
    public static class OverlappingReadsErrorCalculator extends BaseErrorCalculator {
        long nBothDisagreeWithReference = 0;
        long nDisagreeWithRefAndMate = 0;
        long nThreeWaysDisagreement = 0;

        public OverlappingReadsErrorCalculator() {
        }

        @Override
        public void addBase(final SamLocusIterator.RecordAndOffset recordAndOffset, final SAMLocusAndReferenceIterator.SAMLocusAndReference locusInfo) {
            final byte readBase = recordAndOffset.getReadBase();
            final SAMRecord record = recordAndOffset.getRecord();
            final SamLocusIterator.RecordAndOffset mate = locusInfo.getRecordAndOffsets()
                    .stream()
                    .filter(putative -> areReadsMates(record, putative.getRecord()))
                    .findFirst()
                    .orElse(null);

            // we are only interested in bases for which the mate read also has a base over the same locus
            if (mate == null) return;
            // both bases need to be called for this error calculation

            final byte mateBase = mate.getReadBase();
            if (SequenceUtil.isNoCall(readBase)) return;
            if (SequenceUtil.isNoCall(mateBase)) return;

            totalBases++;

            // Only bases that disagree with the reference are counted as errors.
            if (!SequenceUtil.basesEqual(readBase, locusInfo.referenceBase)) return;

            final boolean agreesWithMate = SequenceUtil.basesEqual(readBase, mateBase);
            final boolean mateAgreesWithRef = SequenceUtil.basesEqual(mateBase, locusInfo.referenceBase);

            if (agreesWithMate) {
                nBothDisagreeWithReference++;
            } else if (mateAgreesWithRef) {
                nDisagreeWithRefAndMate++;
            } else {
                nThreeWaysDisagreement++;
            }
        }

        @Override
        public String getSuffix() {
            return "overlapping_error";
        }

        @Override
        public ErrorMetrics.ComputableMetricBase getMetric() {
            return new ErrorMetrics.OverlappingErrorMetric("", totalBases, nDisagreeWithRefAndMate,
                    nBothDisagreeWithReference, nThreeWaysDisagreement);
        }

        private boolean areReadsMates(final SAMRecord read1, final SAMRecord read2) {
            // must have same name
            if (!read1.getReadName().equals(read2.getReadName())) return false;
            // must be paired
            if (!read1.getReadPairedFlag()) return false;
            // one must be first while the other is not
            if (!read1.getFirstOfPairFlag() ^ read2.getFirstOfPairFlag()) return false;
            // one must be second while the other is not
            if (!read1.getSecondOfPairFlag() ^ read2.getSecondOfPairFlag()) return false;
            // read must be mapped
            if (read1.getReadUnmappedFlag()) return false;
            // mate must be mapped
            if (read1.getMateUnmappedFlag()) return false;

            return read1.getMateAlignmentStart() == read2.getAlignmentStart();
        }
    }
}
